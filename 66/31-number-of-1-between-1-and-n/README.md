# 整数中1出现的次数（从1到n整数中1出现的次数）

求出1\~13的整数中1出现的次数,并算出100\~1300的整数中1出现的次数？

为此他特别数了一下1\~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。

ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

## 遍历所有

- 时间O(N)

```cpp
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n) {
        if(n <= 0) return 0;
        int sum_count = 0;
        for(int num = 1; num <= n; num++) {
            int cur_num = num, count = 0;
            while(cur_num) {
                if(cur_num%10 == 1)
                    count++;
                cur_num /= 10;
            }
            sum_count += count;
        }
        return sum_count;
    }
};
```

## 数字特点

- 时间O(log_{10} N)

### 数字特点1

- 链接：https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6  
- 来源：牛客网  

设N = abcde ,其中abcde分别为十进制中各位上的数字。
如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。  

1. 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100\~199，1100\~1199,2100\~2199，，...，11100\~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。
2. 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100\~199，1100\~1199,2100\~2199，，....，11100\~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100\~12113,一共114个，等于低位数字（113）+1。  
3. 如果百位上数字大于1（2\~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100\~199,1100\~1199，2100\~2199，...，11100\~11199,12100\~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。

```cpp
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n) {
        int count = 0, bit = 1;
        while((n/bit) != 0) {
            int cur = (n / bit) % 10; // 当前位数字
            int high = n / bit / 10;  // 高位数字
            int low = n - n / bit * bit; //低位数字
            if(cur == 0) // 当前位为0, 1的个数仅取决于高位
                count += high * bit;
            else if(cur == 1) // 当前位为1, 1的个数取决于高位和低位（低位包括一个0）
                count += high * bit + low + 1;
            else // 当前位大于1, 1的个数取决于高位
                count += (high + 1) * bit;
            bit *= 10; // 进位
        }
        return count;
    }
};
```

### 数字特点2  

主要思路：设定整数点（如1、10、100等等）作为位置点bit（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。对 n 进行分割，分为两部分，高位 `left = n / bit` ，低位 `right = n % bit` 。 

- 当 bit 表示百位，且百位对应的数 >= 2，如 `n = 31456, bit = 100`，则`left = 314, right = 56`，此时百位为 1 的次数有 `left / 10 + 1 = 32`（最高两位的计算是从0到31），此外，每个 1 对应低位的 100 ，都包含 100 个连续的点，即共有`(left / 10 + 1) * 100`个点的百位为 1，即`(left / 10 + 1) * bit`
- 当 bit 表示百位，且百位对应的数为 1，计算包含两部分（高位，低位）。如 `n = 31156, bit = 100`，则`left = 311, right = 56`，此时百位对应的就是 1 ，则高位共有`left / 10`（最高两位的计算是从0到30）次，每个高位都包含低位 100 个连续点，当最高两位为 31 时 （即`left = 311`）；低位的计算只对应点`00~56`，共 `right+1` 次，所有点加起来共有 `(left / 10 * 100) + (right + 1)`，这些点百位对应为 1 ，即 `(left / 10 * bit) + (right + 1)`  
- 当 bit 表示百位，且百位对应的数为 0，如 `n = 31056, bit = 100`，则 `left = 310, right = 56` ，此时百位为 1 的次数有 `left / 10 = 31`（最高两位的计算是从0到30，即`left/10*bit`    

综合以上三种情况：

1. 当百位为 0 ，`left/10*bit`；  
2. 当百位为 1 ，`left/10*bit + right+1`。用`right%10 == 1`来判断低位，区别开百位为0的情况；
3. 当百位 >=2 ，`(left/10+1)*bit`，因 `(left + 8) / 10` 的进位不会影响百位为0和1的情况，因而写为 `(left+8)/10 * bit`。

```cpp
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n) {
        int count = 0; 
        for(long long bit = 1; bit <= n; bit *= 10) {
            // bit 表示当前分析的是哪一个数位
            int left = n / bit, right = n % bit;// 左半边（含当前位），右半边
            count += (left+8)/10*bit + (left%10==1)*(right+1);
        }
        return count;
    }
};
```

## 归纳总结

- 时间O(log_{10} N)
- 链接：https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6
- 来源：牛客网  

首先将位数分类：  

- 个位数，1会每隔10出现一次，例如1、11、21等等，发现以10为一个阶梯的话，每一个完整的阶梯里面都有一个1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯0-9，10-19之中都有一个1，但是19之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）。  

可以归纳个位上1出现的个数为：`n/10*1 + (n%10!=0 ? 1 : 0)` 

- 十位数，出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。那么现在可以归纳：十位上1出现的个数为：  
1. 设`step = n % 100`，即为不完整阶梯段的数字  
2. 归纳式为：`(n / 100) * 10 + (if(step > 19) 10 else if(step < 10) 0 else step - 10 + 1)`  
- 现在说百位1，我们知道在百位，100-199都会出现百位1，一共出现100次，阶梯间隔为1000，100-199这组数，每隔1000就会出现一次。这次假设我们的数为2139。跟上述思想一致，先算阶梯数 * 完整阶梯中1在百位出现的个数，即n/1000 * 100得到前两个阶梯中1的个数，那么再算漏出来的部分139，沿用上述思想，不完整阶梯数step<100则得到0个百位1，step>199，得到100个百位1，100<=step<=199则得到step - 100 + 1个百位1。

- 百位上出现1的个数：  

1. 设`step = n % 1000`  
2. 归纳式为：`(n / 1000) * 100 + (step>199) ? 10 : (step>100 ? 0 : step-100+1)`  
后面的依次类推....  

那么我们把个位数上算1的个数的式子也纳入归纳式中：

1. `step = n % 10`  
2. 个位数上1的个数为：`n / 10 * 1 + (step>1) ? 1 : (step<1 ? 0 : step-1+1)`   

完美！归纳式看起来已经很规整了。来一个更抽象的归纳，设 bit 为计算 1 所在的位数，`bit = 1`表示计算个位数的1的个数，`bit = 10`表示计算十位数的1的个数等等：  

1. `step = n % (bit * 10)`  
2. `count(bit) = (n / (bit * 10)) * bit + (step>bit*2-1) ? bit : (step<bit ? 0 : step-bit+1)`  

好了，这样从10到10的n次方的归纳就完成了：  

`sum1 = sum(count(bit)), bit = Math.pow(10, bit_idx), 0<=bit_idx<=log10(n)`

进一步简化后半段的多个ifelse，进而不计算`bit * 2 - 1`，只需保证`step - bit + 1`在`[0, bit]`区间内，最后后半段：`min(  max( (n mod (bit*10)) −bit+1,0), bit  )`。  

```cpp
class Solution {
    inline int max(int a, int b) { return a > b ? a : b; }
    inline int min(int a, int b) { return a < b ? a : b; }
public:
    int NumberOf1Between1AndN_Solution(int n) {
        if(n <= 0) return 0;
        int count = 0;
        for(long bit = 1; bit <= n; bit *= 10) {
            long diviver = bit * 10;
            count += (n / diviver) * bit + min(max(n % diviver - bit + 1, 0), bit);
        }
        return count;
    }
};
```

## 转为字符串

- 时间：O(N)

无论是一次开辟好所有字符串所需空间或是每次开辟，时间复杂度均为O(N)。

```cpp
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n) {
        int ones = 0; char table[10];
        for(int num = 1; num <= n; num++) {
            sprintf(table, "%d", num);
            ones += count(begin(table), end(table), '1');
        }
        return ones;
    }
};
```
